package main

import (
	"fmt"
	"sync"
)

/*
при заполнении "map" может возникнуть потребность в обращении к одним и тем же данным
у разных потоков одновременно. Соответственно чтобы этого не возникало, используем систему
мьютексов, которые блокируют участки кода, дабы только один поток обрабатывал данные в
один момент времени. (кто первый успел дойти в своем коде до mutex.Lock(),
тот и работает с данными)
*/

var mx sync.Mutex
var datas map[int]string

func main() {
	datas = make(map[int]string)
	var w8 sync.WaitGroup
	var n int = 2

	datas[0] = "lol" //по четному ключу записываем знаечние "лол"
	datas[1] = "kek" //по нечетному - "кек"

	//синхронизируем главный поток с остальными с помощью sync.W8Group
	for i := 0; i < 5; i++ {
		w8.Add(1)
	}

	for i := 0; i < 5; i++ {
		go fill_map(&n, &w8) // запускаем горутину, заполняющую мапу
	}
	w8.Wait()
	fmt.Print("End map\n", datas, "\n")

}

func fill_map(n *int, w8 *sync.WaitGroup) {
	mx.Lock() //лочим переменную 'n' которая соответствует текущему ключу
	if *n%2 == 0 {
		datas[*n] = "lol"
	} else {
		datas[*n] = "kek"
	}
	*n++
	mx.Unlock()  //анлочим, чтобы следующий поток смог использовать переменную 'n'
	(*w8).Done() //посылаем сигнал в мейн-рутину о завершении работы
}
